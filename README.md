[image1]: image/a1.png "img1"
[image2]: image/a2.png "img2"
[image3]: image/a3.png "img3"
[image4]: image/a4.png "img4"

[image5]: image/a5.png "img5"
[image6]: image/a6.png "img6"
[image7]: image/a7.png "img7"
[image8]: image/a8.png "img8"
[image9]: image/a9.png "img9"
[image10]: image/a10.png "img10"

[image11]: image/a11.png "img11"
[image22]: image/a12.png "img12"
[image33]: image/a13.png "img13"
[image44]: image/a14.png "img14"

# path-planning
Path Planning

## Approaches to Path Planning
Three different approaches:

* `Discrete (or combinatorial) path planning`
* `Sample-based path planning`
* `Probabilistic path planning`

## Discrete Planning
Discretize the robot’s workspace into a connected graph, and apply a graph-search algorithm to calculate the best path. It is very computationall very expensive. Therefore, it is best suited for low-dimensional problems. For high-dimensional problems, sample-based path planning is a more appropriate approach.

![alt text][image1]
* Develop a convenient `continuous representation`. This can be done by representing the problem space as the configuration space (C space). C space takes into account the geometry of the robot and makes it easier to apply discrete search algorithms.
* `Discretization`. The configuration space must be discretized into a representation that is more easily manipulated by algorithms.
* `Graph Search`. The descretized space is represented by a graph to use search algorithm. Find the best path from the start node to the goal node. 

### Continuous Representation
Find a curved or piece wise linear path connecting the robot start pose to the goal pose that does not collied with any obstacles.
![alt text][image2]
![alt text][image3]
Inflate every single obstacle by the radius of the robot and then treat the robot as a point.

![alt text][image4]
This kinds of environment is the configuration space(C space). A configuration space is a set of all robot poses. The C space is divided into $C_{free}$ and $C_{obstacle}$. $C_{obstacle}$ is the compliment to $C_{free}$ representing the set of robot pauses that are in collision with obstacles or walls.

### Minkowski Sum
Let P and R be two sets in $\mathbb{R}_{2}$

$P \oplus R$ = {p+r | p $\in$ P $\wedge$ r $\in$ R}

where p+r = ($p_{x}+r_{x}, p_{y}+r_{y}$)

The [Minkowski sum](https://github.com/bmaxdk/path-planning/blob/main/minkowski_sum.cpp) is a mathematical property that can be used to compute the configuration space given an obstacle geometry and robot geometry. To create the configuration space, the Minkowski sum is calculated in such a way for every obstacle in the workspace. The image below shows three configuration spaces created from a single workspace with three different sized robots.
![alt text][image5]
For convex polygons, computing the convolution is trivial and can be done in linear time - however for non-convex polygons (i.e. ones with gaps or holes present), the computation is much more expensive. 
Plot check [RoboND-MinkowskiSum](https://github.com/udacity/RoboND-MinkowskiSum)

### 3D Configuration Space
Configuration space changes depending on the orientation of the robot. The apporpriate way to represent this in the configuration space is to add a dimension. The x-y plane would continue to represent the translation of the robot in the workspace, while the vertical axis would represent rotation of the robot.

The dimension of the configuration space is equal to the number of degrees of freedom that the robot has. While a 2D configuration space was able to represent the x- and y-translation of the robot, a third dimension is required to represent the rotation of the robot. A three-dimensional configuration space can be generated by stacking two-dimensional configuration spaces as layers.
![alt text][image6]
The image above displays the configuration space for a triangular robot that is able to translate in two dimensions as well as rotate about its z-axis. 
[Configuration Space Visualization](https://www.youtube.com/watch?v=SBFwgR4K1Gk&ab_channel=Dr.DrorAtariah)

### Roadmap
These methods represent the configuration space using a simple connected graph - similar to how a city can be represented by a metro map.

![alt text][image7]

Roadmap methods are typically implemented in two phases:

* The `construction phase` builds up a graph from a continuous representation of the space. This phase usually takes a significant amount of time and effort, but the resultant graph can be used for multiple queries with minimal modifications.
* The `query phase` evaluates the graph to find a path from a start location to a goal location. This is done with the help of a search algorithm.

### Visibility Graph
The Visibility Graph builds a roadmap by connecting the start node, all of the obstacles’ vertices, and goal node to each other - except those that would result in collisions with obstacles. The Visibility Graph has its name for a reason - it connects every node to all other nodes that are ‘visible’ from its location.

* `Nodes`: Start, Goal, and all obstacle vertices.
* `Edges`: An edge between two nodes that does not intersect an obstacle, including obstacle edges.

![alt text][image8]

The motivation for building Visibility Graphs is that the shortest path from the start node to the goal node will be a piecewise linear path that bends only at the obstacles’ vertices. This makes sense intuitively - the path would want to hug the obstacles’ corners as tightly as possible, as not to add any additional length. In certain applications, such as animation or path planning for video games, this is acceptable. However the uncertainty of real-world robot localization makes this method impractical. [Complete and optimal path]

### Voronoi Diagram
Another discretization method that generates a roadmap is called the Voronoi Diagram. Unlike the visibility graph method which generates the shortest paths, Voronoi Diagrams maximize clearance between obstacles. A Voronoi Diagram is a graph whose edges bisect the free space in between obstacles. Every edge lies equidistant from each obstacle around it - with the greatest amount of clearance possible.

![alt text][image9]

Once a Voronoi Diagram is constructed for a workspace, it can be used for multiple queries. Start and goal nodes can be connected into the graph by constructing the paths from the nodes to the edge closest to each of them.

Every edge will either be a straight line, if it lies between the edges of two obstacles, or it will be a quadratic, if it passes by the vertex of an obstacle. [Complete path]

### Cell Decomposition
Another discretization method that can be used to convert a configuration space into a representation that can easily be explored by a search algorithm is `cell decomposition`. Cell decomposition divides the space into discrete cells, where each cell is a node and adjacent cells are connected with edges. There are two distinct types of cell decomposition:

* Exact Cell Decomposition
* Approximate Cell Decomposition.

#### Exact Cell Decomposition
Exact cell decomposition divides the space into `non-overlapping cells`. This is commonly done by breaking up the space into triangles and trapezoids, which can be accomplished by adding vertical line segments at every obstacle’s vertex. 
![alt text][image10]
Once a space has been decomposed, the resultant graph can be used to search for the shortest path from start to goal.
![alt text][image11]
Exact cell decomposition is elegant because of its precision and completeness. Every cell is either ‘full’, meaning it is completely occupied by an obstacle, or it is ‘empty’, meaning it is free. And the union of all cells exactly represents the configuration space. If a path exists from start to goal, the resultant graph will contain it.

To implement exact cell decomposition, the algorithm must order all obstacle vertices along the x-axis, and then for every vertex determine whether a new cell must be created or whether two cells should be merged together. Such an algorithm is called the `Plane Sweep algorithm`.

#### Approximate Cell Decomposition



## Sample-Based Planning
Sample-based path planning probes the workspace to incrementally construct a graph. Instead of discretizing every segment of the workspace, sample-based planning takes a number of samples and uses them to build a discrete representation of the workspace. The resultant graph is not as precise as one created using discrete planning, but it is much quicker to construct because of the relatively small number of samples used. A path generated using sample-based planning may not be the best path, but in certain applications - it’s better to generate a feasible path quickly than to wait hours or even days to generate the optimal path.


## Probabilistic Path Planning
While the first two approaches looked at the path planning problem generically - with no understanding of who or what may be executing the actions - probabilistic path planning takes into account the uncertainty of the robot’s motion. It's used in reinforcement learning as well such as reward.

